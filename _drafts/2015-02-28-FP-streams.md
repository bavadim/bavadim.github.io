---
layout: post
title: "Заметки о ФП: потоки и ленивые вычисления"
comments: true
categories: programming
---

Сегодня я хотел бы рассказать о потоках (Streams) и ленивых вычислениях.

## Потоки

Функциональные программы могут выглядеть красиво с математической точки зрения, но быть крайне неэффективными. Предположим, что нам нужно найти второе по возрастанию простое число в отрезке от 1000 до 100000. Код может выглядеть как-то так:

    ((1000 to 10000) filter isPrime)(1)

Этот код сначала генерирует список из девяти тысяч элементов, создает отфильтрованный список и возвращает его второй элемент. Красиво, но очень не эффективно. В императивных языках мы бы скорее всего написали такой код: 

    int res_num = 0
    for (i = 1000; i <= 10000; ++i) {
        if (isPrime(i))
            ++res_num;
        if (res_num == 2)
            return i;
    }

Этот код гораздо эффективнее функцонального, так как выполняет только необходимые рассчеты. В случае функционального программирования мы можем не вычислять хвост списка до тех пор, пока он нам не понадобиться. Эта идея реализована в концепции потока (stream). Поток в Scala реализован в виде класса `Stream`, интерфейс которого схож с интерфейсам списка. Но, в отличии от списка, хвост потока вычисляется по необходимости.
Поток можно объявить так:

    val xs = Stream.cons(1, Stream.cons(2, Stream.cons(3, Stream.empty))) // 1-й способ
    val ys = Stream(1, 2, 3) //2-й способ
    val zs = (1 to 3).toStram //3-й способ, действует на любой коллекции

Метод `cons`, как и для списков, имеет псевдоним-оператор `#::`:

    x #:: xs == Stream.cons(x, xs)

Потоки, в общем, внешне очень похожи на списки. Но в главном они отличаются - наш пример с использованием потоков будет работать так же эффективно, как императивный цикл:

    ((1000 to 10000).toStream filter isPrime)(1)

Разберемся, как потоки устроены. Объявление интерфейса Stream:

    trait Stream[+A] extends Seq[A] {
        def isEmpty: Boolean
        def head: A
        def tail: Stream[A]
        ...
    }

Для разнобразия определим Stream немного не так как мы [определяли список](), но суть почти не измениться:

    object Stream {
        def cons[T](hd: T, tl: => Stream[T]) = new Stream[T] {
            def isEmpty = false
            def head = hd
            def tail = tl
        }
    
        val empty = new Stream[Nothing] {
            def isEmpty = true
            def head = throw new NoSuchElementException(”empty.head”)
            def tail = throw new NoSuchElementException(”empty.tail”)
        }
    }

Важное отличие от списка тут только одно - передача аргумента `tl` в `cons` по имени, а не по значению. Таким образом хвост потока не вычисляется по месту вызова функции. Он вычисляется лишь тогда, когда кто-то вызовет `tail`. В свою очередь хвост - тоже поток и, следовательно, будет вычислена только голова потока (если поток не `Stream.empty`).

Другие методы реализованы по тому же принципу, вот например метод `filter`:

    def filter(p: T => Boolean): Stream[T] =
        if (isEmpty) this
        else if (p(head)) cons(head, tail.filter(p))
        else tail.filter(p)

Потоки позволяют нам вычислять только то, что необходимо. Но в отличии от списков они менее предсказуемы и простое чтение второго элемента может занять много времени.

## Ленивые вычисления

Представим, что в программе у одного и того же потока мы вызываем `tail` несколько раз. Это может привести к серьезным проблемам производительности, так как при каждом вызове `tail` будут происходить одни и те же вычисления. Так как в функциональных программах объекты неизменны мы бы могли сохранить результаты первого вычисления и использовать их позже. Такая оптимизация называется *ленивыми вычислениями*, обычные вычисления называются *строгими* (подробнее в [википедии](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)).

В Scala по-умолчанию ключевое слово `val` строго вычисляет выражение. Для ленивого вычисления выражения служит конструкция `lazy val`. Улучшим поток с помощью ленивых вычислений:

    def cons[T](hd: T, tl: => Stream[T]) = new Stream[T] {
        def head = hd
        lazy val tail = tl
        ...
    }

Теперь мы сможем вычислять только то, что нам нужно.

## Пример использования

Так как мы вычисляем следующий элемент потока по необходимости, то мы можем использовать бесконечные потоки. Например, вот пример метода, генерирующего последовательность чисел, начиная с заданного значения: 

    def from(n: Int): Stream[Int] = n #:: from(n+1)

Далее мы можем использовать поток в вычислениях:

    val nats = from(0)  // > Stream(0, ?)
    nats map (_ * 4)    // > Stream(0, ?)

Мы можем комбинировать операции, которые будут вычисляться по необходимости! Давайте рассмотрим более практический пример. Реализуем поиск простых чисел с помощью решета Эратосфена. Идея этого алгоритма достаточно проста:

    1. выписываем подряд все целые числа от 2 до какого-то n, ни одно не зачеркнуто
    2. взять первое не зачеркнутое число - это простое число, добавить в результирующее множество
    3. зачеркнуть все числа, кратные взятому числу
    4. если больше нет не зачеркнутых чисел - вернуть результирующее множество, иначе перейти на шаг 3

Вот демонстрация работы алгоритма из википедии:

![alg](/images/6/New_Animation_Sieve_of_Eratosthenes.gif)

Реализуем этот алгоритм следующим образом. Сначала определим функцию, создающую поток всех простых чисел от 2х до бесконечности. Далее вычислим n необходимых элементов потока. Функция:

    def sive: Stream[Int] = {
        def sieve_from(s: => Stream[Int]): Stream[Int] = 
            s.head #:: sieve_from(s.tail filter (_ % s.head != 0))
    
        sieve_from(from(2))
    }

Собственно вычисление первых 4-х простых чисел:

    (sive take 4).toList // List(2, 3, 5, 7)

Подумайте, что будет, если `s` в `sieve_from` передавать не по имени, а по значению.
